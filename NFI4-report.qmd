---
title: "NFI 4 analytical report"
subtitle: ""
author: "Gael Sola, FAO, Chip Scott, USFS (retired), Jeremy Ferrand (JICA), !!ADD OTHERS"
date: "August 2025"
# execute:
#   echo: false
format:
  html: 
    toc-location: left
    embed-resources: true
    theme: 
      light: flatly
      dark: darkly
    highlight-style: github
    #code-block-border-left: "#00BC8C"
    code-fold: false
    code-tools: 
      source: false
    code-summary: "Show the code"
  docx:
    #toc: true
    #number-sections: true
    highlight-style: github
    reference-doc: custom-reference-doc.docx
  pdf:
    documentclass: scrartcl
    papersize: A4
    #toc: true
    #number-sections: true
    #number-depth: 2
    colorlinks: true
number-sections: true
toc: true
toc-depth: 2
editor: visual
---

# Preamble {.unnumbered}

This report was written as a [Quarto document](https://quarto.org/) and developed with R Quarto. The tables, figures and numbers are automatically generated from the R scripts used to analyze Lao PDR national forest inventory cycle 4, carried out in 2024 and 2025. The code base and quarto document are available at: <https://github.com/R-Forest-LAO-2024/NFI-calc-chain-2025/>.

The code base itself is split into 3 groups of scripts with different objectives:

-   Setup: load libraries, setup the environment and get the data from an initial master table in the ONA server into split tables by entity.

-   User: clean the data, join attributes, calculate entity level variables from field measurements, run aggregation functions to get the final results.

-   Analytics: custom functions that aggregate data from the smallest area unit tom the domain and sub-population of interest.

The whole sequence can be run from the master script: **'R/nfi-lao-cycle4-main.R'**.

```{r}
#| output: false

## Run all the code base
source("R/nfi-lao-cycle4-main.R")

```

# Executive summary {.unnumbered}

## Description of NFI Cycle 4 {.unnumbered}

Lao implemented three cycles of national forest inventories (NFIs) between XX and XX. A major revision of its design took place in 2023 and 2024 with collaborative support from GIZ and the Goettingen University on one side, and Silvacarbon and the US Forest service on the other side.

This collaboration led to a improved two-phases systematic sampling design. The initial phase consisted of the visual observation of all the plot centers on a 6 by 6 km grid, followed by a second phase were all the plots on a larger 12 x 18 km grid were marked for field measurement (phase II). The phase II plots were designed as clustered-plots composed by four 16 m radius subplots on a L shape, numbered A, B, C (south to north) and D (east of subplot A) and separated by 60 meters center to center.

Two major changes impacted the design during implementation:

1.  Not all initial phase II plots were visited. This forced a change in design from systematic to stratified, in order to account for the fact that plots in different strata had different probability of selection.

2.  Since land cover was recorded for each subplot and in practice on 5 observation points on each subplot (20 land cover section per plot), a ratio estimator approach was necessary to account for unequal plot area at the domain level (in this case domain = land cover type).

As a result, the overall analytical approach was: **two-phase sampling for post-stratification with ratio estimator**.

The data analysis objective was to calculate entity level variables, such as tree volume, tree biomass or deadwood biomass, from field measurement and aggregate them to domain level (land cover class). The detailed tep-by-step process was:

-   Data preparation: transformation of ONA raw data into entity level tables,

-   Data cleaning: manual correction of data entry errors (very few) and mistake in coding plot, subplot and entities identification numbers.

-   Entity level calculation: join attribute from different levels and calculate entity variables such as basal area, volume and biomass.

-   Aggregation to domain estimates: aggregation of entity variables to domain estimates with uncertainty of sampling error. Aggregation levels:

    -   entity level to the smallest area unit (subplot x land cover section in the new NFI cycle 4 design),

    -   smallest area unit to plot level,

    -   plot level to sub-population and strata level,

    -   sub-population and strata level to sub-population level,

    -   sub-population level to totals for the all domains.

The strata were defined as (1) natural forest, (2) forest plantations, (3) regenerating vegetation and (4) non-forest, and assigned at the plot level from the phase I observations.

Different sub-populations were defined: no sub-population, (1) ERPA provinces and (2) all other provinces in two different sub-populations, or each province is a different sub-population. When sub-populations were defined, the sub-population level tables provided the ratio estimates for all sub-populations with their confidence intervals.

## Key implementation numbers {.unnumbered}

The phase I one this inventory cycle was carried out from XX to XX and consisted of the interpretation of `r format(val$nplot_ph1, big.mark = ",")` plots on a 6 x 6 km grid. Nearly half the plots were natural forest, the rest mostly shared between non-forest and regeneration, and very plots were found on plantations areas (@tbl-ph1).

```{r}
#| echo: false
#| label: tbl-ph1
#| tbl-cap: "Number of plots per stratum in the phase I."

knitr::kable(tab$Nh, format.args = list(big.mark = ','))

```

Out of all the phase I plots, a systematic subset of `r format(val$nplot_ph2, big.mark = ",")` plots were selected on a 12 x 18 km grid for the NFI phase II: the field measurement campaign. From these plots `r format(val$nplot_visit, big.mark = ",")` were visited and `r format(val$nplot_access, big.mark = ",")` were at least partially accessible (@tbl-ph2). The field work phase took place from XX to XX. A portion of these plots were visited a second time for QAQC procedures. See @sec-annex-qaqc in annex for more details on QAQC results.

```{r}
#| echo: false
#| label: tbl-ph2
#| tbl-cap: "Number of plots in the NFI phase II planned, visited and accessed."

knitr::kable(tab$access, format.args = list(big.mark = ','))

```

The non-visited plots in strata 1 to 3 (all except non-forest) were considered as non-accessible and removed from the analysis. The non-visited plots in strata 4 (non-forest) were considered accessible with biomass 0. All non-forest plots were considered having 0 biomass as no allometric equation was chosen for the trees in visited and accessed non-forest plots.

In total, `r format(nrow(tree), big.mark = ",")` trees, `r format(nrow(dw), big.mark = ",")` standing dead trees and `r format(nrow(stump), big.mark = ",")` stumps were measured in the 8 and 16 m radius nested subplots. Saplings and lying deadwood were also measured in a 2 m radius circle and lying deadwood was measured on a 32 m line transect for each subplot (@tbl-entity).

```{r}
#| echo: false
#| label: tbl-entity
#| tbl-cap: "Number of measured individuals per entity."

knitr::kable(tab$entity, format.args = list(big.mark = ','))

```

## Core NFI result: forest carbon {.unnumbered}

The main result of the analysis were the biomass of different pools (live trees aboveground, live trees belowground, sapling aboveground, deadwood, stumps and lying dead wood) in ton of biomass per ha and the average total carbon of all domains (in ton C per ha). The total carbon is presented in @tbl-carbon1 and @tbl-carbon2 and the other results, including per province estimations can be found in the report or its annexes.

```{r}
#| echo: false
#| label: tbl-carbon1
#| tbl-cap: "Total carbon stock per land cover class in tC/ha, no subpopulation."

knitr::kable(tab$carbon1, format.args = list(big.mark = ","))

```

```{r}
#| echo: false
#| label: tbl-carbon2
#| tbl-cap: "Total carbon stock per land cover class in tC/ha, ERPA subpopulation."

knitr::kable(tab$carbon1, format.args = list(big.mark = ","))
```

# Introduction

## Context

TBD

## Objective

The main objective of the analysis was to estimate Lao PDR forest carbon stocks, in per hectare values and as total quantity, over the country or different administrative units (or subpopulations) and land cover classes (or domains).

This reports present the method and results of the analysis.

# Method

## NFI sampling design

### Representation of land uses

TBD

### Stratification

TBD

### phase I sampling

TBD

### phase II sampling

TBD

## NFI plot design

TBD

## NFI response design

TBD

# Analysis of the data

## Data preparation

The initial scripts were developed to retrieve the data directly from the ONA server into R as one master CSV (see ONA API instructions: <https://api.ona.ilri.org/static/docs/data.html>), or from manually downloaded tables as a ZIP file or as a [**CSV with long names**]{.underline} (see ONA interface download options).

Rstudio allows to request passwords, without storing them to maintain security, with the command `rstudioapi::askforsecret()`. With the `keyring` package installed, the password can even be stored securely in the operating system's keyring backend to avoid having to re-enter every time.

Nevertheless, it was decided that the data would be downloaded manually by FIPD and shared with experts and analysts. In this case, the data was stored in the following directory inside the R project: *'data/data-source/'*, and user inputs were set in Code @lst-usrinput.

Notice in Code @lst-usrinput that the CSV file of the phase I data was placed in the ancillary data folder: *'data/data-ancillary/'*, and its file name added to the user inputs as well.

The data preparation was automated and part of the setup group of scripts in *'R/setup/'*. In particular *'get-data.R'* and *'load-anci.R'* took care of loading the raw data and splitting the master CSV file into entity level tables: subplot, tree, dw, sapling and ldw, and split out the QAQC re-measurements into separate tables. At this stage, all the entity tables were grouped in the R global Environment into an object (specifically a list) called: `data-prep`.

## Data correction

The data correction scripts were placed in the user group of scripts, in *'R/user/'*, and developed manually to investigate and solve potential errors for each entity table. During this phase the five land cover observations for each subplot were separated from the subplot table into their own table: `lcs`, short for land cover section.

### Subplot corrections

At subplot level the main type of issue found was entry error of subplot code (duplicates in A, B, C or D) and plot code. They were solved manually by looking at time stamps, see Code @lst-spcorr.

### Creating the land cover sections

In addition to the plot / subplot structure there were 5 five observation points for land cover in each subplots. These five points were located as follow: center point at the subplot center, then north, east, south and west points point at 12 m of the subplot center towards north, east, south and west respectively. These 5 points represent land cover sections for which an area can be calculated and assign to trees based on equi-distance or Thiessen polygons. As a result, land cover sections (LCS) were created as follows (@fig-lcs):

-   center: a square of 12 m side centered on the subplot center

-   north, east, south and west : a quarter of the larger subplot circle of 16 m radius minus the center square, split respectively by the northwest (315 degrees) and northeast (45 degrees), northeast and southeast (135 degrees), southeast and southwest (225 degrees), and southwest and northwest lines.

```{r}
#| echo: false
#| label: fig-lcs
#| fig-cap: "Example of land cover sections (LCS) and their trees assignements in one subplot" 

fig$lcs_ex


```

### Live tree corrections

### Sapling corrections

### Standing deadwood corrections

### Lying deadwood corrections

## Entity level calculations

### Tree weight

In the context of ratio estimator, the sum of trees' characteristics is required at plot level rather than their per hectare value. Weights were therefore used to estimate the sum of tree characteristics in the 16 m radius circle for small trees that were measured in the 8 m radius circle (@eq-treeweight, @lst-treeweight).

$$
w_{tree} = 
  \begin{cases} 
    \text{4   when D} \le \text{30 cm} \\ 
    \text{1   when D > 30 cm} 
  \end{cases}
$$ {#eq-treeweight}

### Tree basal area

Basal area (BA) is calculated as follows:

$$
BA = \pi \times {r}^{2} = \pi \times {\left(\frac{D}{200}\right)}^{2}
$$ {#eq-tree-ba}

Its calculation was implemented in the Code @lst-treeba.

### Tree aboveground biomass

Aboveground biomass was estimated for each tree using allometric equations linking it to field measurements (species, DBH, land cover). Land cover was assigned at the land cover section level. The equations were based on literature, mostly from neighbor countries and pan-tropical models (@tbl-allometry, Code @lst-treeagb).

```{r}
#| echo: false
#| label: tbl-allometry
#| tbl-cap: "Aboveground biomass allometric equations for trees and deadwood. Sources: (1), ..., (8) A. Chantuma, T. Wichitchonlachai, and P. Chantuma, Rubber new planting in Thailand: towards the world affected on climate change, Rubber Thai. 1, 40â€“47 (2012)"

knitr::kable(tab$allometry, format.args = list(big.mark = ","), escape = FALSE)
```

Land cover-based tree AGB was compared with the Evergreen forest model and two pantropical models from Chave et al, 2005 (@eq-chave05) and 2014 (@eq-chave14) without height, respectively:

$$
\text{AGB} = 0.6 \times exp\left(-1.499 + 2.148 \times log(D) + 0.207 \times log(D)^2 - 0.0281 \times log(D)^3\right)
$$ {#eq-chave05}

and

$$
AGB = exp\left(-1.803 - 0.976 \times E + 0.976 \times log(0.6) + 2.673 \times log(D) - 0.0299 \times log(D)^2\right)
$$ {#eq-chave14}

Figures [-@fig-treeagb] and [-@fig-treeagbp] show that the selected models were all conservative, except the models bamboo (B), regenerative vegetation (RV) and rubber plantation model, but the MRV team felt comfortable that the models selected were adequate for Lao PDR.

```{r}
#| echo: false
#| label: fig-treeagb
#| fig-cap: "Comparison of AGB models for natural forests" 

fig$tree_agb

```

```{r}
#| echo: false
#| label: fig-treeagbp
#| fig-cap: "Comparison of AGB models for forest plantations" 

fig$tree_agbp

```

### Tree belowground biomass

Tree belowground biomass was calculated at the tree level as $BGB = RS \times AGB$, with RS the root-to-shoot ratio to convert aboveground to belowground biomass. The root-to-shoot ratios were based on land cover and plot level aboveground biomass, and taken from IPCC 2006 for non-coniferous (table guidelines, ch.4 vol.4 table 4.4) and XX (ADD SOURCE) for coniferous forests (@tbl-rs).

```{r}
#| echo: false
#| label: tbl-rs
#| tbl-cap: "Root-to-shoot ratios for converting aboveground to belowground biomass"

knitr::kable(tab$rs, format.args = list(big.mark = ","))

```

To apply the root-to-shoot ratios to each tree, land cover information was taken from land cover sections and plot AGB was calculated at the subplot level and re-assigned to trees (Code @lst-treebgb). The justification for choosing subplot level for AGB aggregation for RS, was that the land cover sections were too small in area and could yield wild AGB values.

### Sapling aboveground biomass

TBD

### Standing deadwood aboveground biomass

TBD

### Stump aboveground biomass

TBD

### Lying deadwood biomass

TBD

## Aggregation

### Guiding example

This section introduces the mathematical formulas used to aggregate the tree level data to the domain level estimates and the country level totals. Since the formulas can quite complex, a subset of 5 phase II plots and 20 phase I plots was selected to serve as a guiding example (see @exm-guidex-intro).

:::: {.callout-tip appearance="simple"}
<!-- #01 guidex intro -->

::: {#exm-guidex-intro}
## Introducing guiding example

\linebreak

To illustrate the formulas and step-by-step aggregation of the NFI data from entities to domain totals, a subset of 5 phase II plots (3 DD, 1 RV, 1 mix) and 20 phase I plots (15 RV, 5 DD) was prepared (see @tbl-guidex-ph1 and @tbl-guidex-ph2init-10rows. The guiding example was also limited to live trees and AGB aggregation, but the principles are the same for other entities and attributes. All the initial tree data is presented in @sec-annex-guidex.

The 5 phase II plots were prepared as follows:

-   3 plots in Dry dipterocarp forest (land cover code DD or land cover number 13), with plot IDs: 50, 126, 128.

-   1 plot in regenerating vegetation (land cover code RV or land cover number 22), with plot ID 157.

-   1 plot in mix land cover, with plot ID 1 and subplots A, B and C in dry dipterocarp forest and subplot D split between dry dipterocarp forest in land cover sections D1, D4 and D5, and regenerating vegetation in land cover sections D2 and D3.

```{r}
#| echo: false
#| label: tbl-guidex-ph1
#| tbl-cap: "Guiding example phase I subset."

knitr::kable(guidex$ph1_data, format.args = list(big.mark = ','))
```

```{r}
#| echo: false
#| label: tbl-guidex-ph2init
#| tbl-cap: "Guiding example phase II initial subset."

knitr::kable(head(guidex$ph2_init), format.args = list(big.mark = ','))

```
:::
::::

### Aggregation to the minimal area unit

In the NFI cycle 4, the minimal unit area was the subplot's land cover section, i.e. the area defined by setting equi-distance between the five land cover observation points for each subplot.

::: callout-note
In the whole aggregation chapter, subplots equal to land cover sections and refer to this minimal area unit that constitute the initial aggregation of entities to a measurement area.
:::

The initial `ph2_subplot` table was generated from all possible combinations of phase II plot numbers, subplot numbers (A, B, C or D) and land cover section (1 to 5).

Each entity table's variables were then summed to the subplot level.

The area of each subplot $j$ of a plot $i$ was:

$$
A_{i,j} = 
\begin{cases} 
12^2/10000 = 0.0144 \space \text{ ha, for center land cover section} \\
(\pi \times 16^2 - 12^2) / 40000 = 0.0165 \space \text{ ha, for other land cover sections}
\end{cases}
$$ {#eq-lcs-area}

For tree, deadwood and stumps entities, the harmonized values of the different measured and calculated variables were aggregated top the subplot level as follows:

$$
X_{y,i,j} = \sum_k{X_{y,i,j,k} \times w_y}
$$

with $X$ the calculated variable (ex. biomass or basal area), $y$ the entity (tree, stump or deadwood) and $i,.j$ the plot and subplot number respectiveley.

::: {.callout-tip appearance="simple"}
<!-- #02 guidex aggregastion to subplot -->

## Aggregating tree to subplot {#exm-aggsp}

Here the tree AGB was summed to the subplot level either in R with `group_by()` and `summarise()` or in MS Excel with SUMIFS() or pivotTable. The tree aggregated data was then combined with the initial phase I subplot data. In R use `left_join()` from the subplot initial table to make sure all subplots are there even if there are no trees (see @tbl-guidex-ph2).

TIP: Replace potential NAs with 0 in AGB values, with `if_else(is.na(X), 0, X)`, X being the variable aggregated.

```{r}
#| echo: false
#| label: tbl-guidex-ph2
#| tbl-cap: "phase II subplot with tree AGB and area."

knitr::kable(guidex$ph2_subplot, format.args = list(big.mark = ','))
```
:::

### Aggregation to domain and totals

Aggregation steps:

1.  aggregation from subplots to partial plots

2.  aggregation of partial plots to (subpopulation) and stratum

3.  aggregation to (subpopulation)

4.  domain totals

In case there is no subpopulation, step 3 gives the totals.

#### Subplots to partial plots

For an attribute $y_{ij,d}$ of plot $i$, subplot $j$ in domain $d$ the formula is

$$
y_{i,d} = \sum_j y_{i,j,d}
$$

For area attributes, the area is considered 0 when not accessible. The aggregation of measurement area $x_{i,j,d}$ for a domain $d$, plot $i$ and subplot $j$ and the total plot measurement $a_{i,j}$, regardless of domain are therefore:

$$
x_{i,d} = \sum_j \delta_j \times x_{i,j,d}
$$ $$
a_{i} = \sum_j \delta_j \times a_{i,j}
$$

with $\delta_j$ = 1 with the subplot $j$ is accessible and $\delta_j$ = 0 when not accessible.

::: {.callout-tip appearance="simple"}
## Subplot to plot aggregation {#exm-plotsum}

Plot no.1 is composed of 20 subplots, 18 in DD, and 2 in RV. When aggregating subplots to plot level, there are 2 partial plots:

$$
\text{AGB}_{i = 1,DD} = \sum_{j=A1}^{D5} AGB_{i = 1,j,DD} 
\space \text{  and  } \space 
\text{AGB}_{i = 1,RV} = \sum_{j=A1}^{D5} AGB_{i = 1,j,RV}
$$

Here:

$y_{i=1, DD} = AGB_{i=1, DD} \sim 3.7 + 1.3 + 3.4 + 2.1 + 1.1 + 1.1 + 0.9 + 0.5 + 3.1 + 0.6 + 1.8 + 1.1 \sim 20.7 \space tons$

$y_{i=1, RV} = AGB_{i=1, RV} \sim 1.3 + 0.0 \sim 1.3 \space tons$

Since the 2 subplots RV are not centers, the partial plot areas are:

$x_{i=1,DD} = 4 \times 0.0144 + 14 \times 0.0165 \sim 0.289 \space ha$

and

$x_{i=1,DD} = 2 \times 0.0165 \sim 0.033 \space ha$

And the accessible area at plot level, since all subplots are accessible in the example:

$a_{i=1} = 4 \times 0.0144 + 16 \times 0.0165 \sim 0.32 \space ha$

The results for all plots are in @tbl-guidex-plotsum.

```{r}
#| echo: false
#| label: tbl-guidex-plotsum
#| tbl-cap: "Guided example: plot summary."

knitr::kable(guidex$plotsum, format.args = list(big.mark = ','))
```
:::

This led to the 'plot-summary' table in the results workbook. Each row of the 'plot-summary' table is a partial plot with unique combination of plot ID and domain.

#### Partial plots to subpopulation and stratum

Overall formula:

$$
R_d = \frac{Y_d}{X_d}
$$

# Results

## Country level

## Subpopulation intermediate results

#### ERPA level

#### Province level aggregates

# Conclusion

TBD

# Annex: Data for the guiding example {#sec-guidex}

To help understand the aggregation process, a subset of 20 phase I plots and 5 phase II plots were used. The phase II plots include 1 mixed land use plot: 18 subplots x land cover sections in Dry Dipterocarp forests (DD) and 2 subplots x land cover sections in Regenerative Vegetation (RV). The 4 other plots are pure, 3 in Dry Dipterocarp and 1 in Regenerative Vegetation. The 20 phase I plots we selected to include the phase II plots are respect the ratio of RV to DD, which is around 3/4 RV, 1/4 DD in the full dataset (see @tbl-ex-ph1 and @tbl-ex-tree).

```{r}
#| echo: false
#| label: tbl-ex-ph1
#| tbl-cap: "phase I information for the guiding example"

knitr::kable(guidex$ph1_data, format.args = list(big.mark = ","))
```

\pagebreak

```{r}
#| echo: false
#| label: tbl-ex-tree
#| tbl-cap: "phase II tree measurements for the guiding example"

knitr::kable(guidex$tree_init, format.args = list(big.mark = ","))


```

# Annex : QAQC plot revisited results {#sec-annex-qaqc}

TBD

# Annex : R scripts code base {#sec-annex-r}

## Data preparation

```{r}
#| eval: false
#| echo: true
#| lst-label: lst-usrinput
#| lst-cap: "User inputs at the time of reporting in the script 'R/user/00-user-inputs.R'"
#| file: "R/user/00-user-inputs.R"

```

## Data correction

### Subplot corrections

```{r}
#| eval: false
#| echo: true
#| lst-label: lst-spcorr
#| lst-cap: "Code snippets with plot and subplot ID corrections."
#| filename: "Extract from R/user/00a-clean-subplot.R"

tmp$subplot1 <- data_prep$subplot |>
  mutate(
    subplot_no = case_when(
      ONA_index == 109 ~ "B", ## 631C is actually 631B
      ONA_index == 113 ~ "B", ## 632C is actually 632B
      ONA_index == 265 ~ "C", ## 553D is actually 553C
      ONA_index == 440 ~ "C", ## 336B is actually 336C
      ONA_index == 980 ~ "B", ## 232C is actually 232B
      TRUE ~ subplot_no
    ),
    subplot_plot_no = case_when(
      ONA_index == 1269 ~ 333, ## plot_no typo, should be 333
      ONA_index == 1270 ~ 333,
      ONA_index == 1271 ~ 333,
      ONA_index == 1272 ~ 333,
      ONA_index == 1417 ~ 359, ## plot_no 369(B) is actually 359(B)
      TRUE ~ subplot_plot_no
    )
  )

tmp$subplot2 <- tmp$subplot1 |>
  mutate(
    subplot_plot_no = case_when(
      subplot_crew_lead == 2 & ONA_index ==  102 ~ 636, # subplot_id == "0363B"
      subplot_crew_lead == 4 & ONA_index == 1135 ~ 168, # subplot_id == "0198D"
      subplot_crew_lead == 6 & ONA_index ==  270 ~ 554, # subplot_id == "0054C"
      subplot_crew_lead == 6 & ONA_index == 1069 ~ 414, # subplot_id == "0141A"  
      subplot_crew_lead == 8 & ONA_index ==  819 ~ 419, # subplot_id == "0149D"
      TRUE ~ subplot_plot_no
    )
  )

tmp$subplot3 <- tmp$subplot2 |>
  filter(!ONA_index %in% c(1819, 2237, 2245)) |>
  mutate(
    subplot_no = case_when(
      ONA_index == 2125 ~ "C", ## issue with 620B duplicate, so B becomes C and C becomes D
      ONA_index == 2126 ~ "D",
      ONA_index ==  103 ~ "C", ## issue with 627B
      TRUE ~ subplot_no
    )
  )
```

### Creating the land cover sections

### Live tree corrections

### Sapling corrections

### Standing deadwood corrections

### Lying deadwood corrections

## Entity level calculations

### Tree weight

```{r}
#| eval: false
#| echo: true
#| lst-label: lst-treeweight
#| lst-cap: "Code snippet for tree weights."
#| filename: "Extract from R/user/02-tree-weight.R"

tree <- tree |>
  mutate(
    tree_weight = case_when(
      tree_dbh <= 30 ~ pi * 16^2 / (pi * 8 ^2),
      tree_dbh > 30  ~ 1 
    )
  )

```

### Tree basal area

```{r}
#| eval: false
#| echo: true
#| lst-label: lst-treeba
#| lst-cap: "Code snippet for tree weights."
#| filename: "Extract from R/user/03-tree-ba.R"

tree <- tree |>
  mutate(
    tree_ba = round(pi * (tree_dbh / 200)^2, 2)
  )

```

### Tree aboveground biomass

```{r}
#| eval: false
#| echo: true
#| lst-label: lst-treeagb
#| lst-cap: "Code snippet for tree aboveground biomass."
#| filename: "Extract from R/user/04-tree-agb.R"

tree <- tree |>
  mutate(
    tree_agb_final = case_when(
      lu_code_new == "EG"    ~ 0.3112 * tree_dbh^2.2331,
      lu_code_new == "MD"    ~ 0.523081 * tree_dbh^2,
      lu_code_new == "DD"    ~ 0.2137 * tree_dbh^2.2575,
      lu_code_new == "CF"    ~ 0.1277 * tree_dbh^2.3944,
      lu_code_new == "MCB"   ~ 0.1277 * tree_dbh^2.3944,
      lu_code_new == "P_AC"  ~ 0.1173 * tree_dbh^2.454,
      lu_code_new == "P_EC"  ~ 0.199 * tree_dbh^2.185,
      lu_code_new == "P_RB"  ~ 0.0082 * (pi*tree_dbh)^2.5623,
      lu_code_new == "P_TK"  ~ 0.077 * tree_dbh^2.546,
      lu_code_new == "P_OTH" ~ 0.3112 * tree_dbh^2.2331,
      lu_code_new == "RV"    ~ 0.6 * exp(-1.499 + 2.148 * log(tree_dbh) + 0.207 * (log(tree_dbh))^2 - 0.0281*(log(tree_dbh))^3),
      lu_code_new == "B"     ~ 0.6 * exp(-1.499 + 2.148 * log(tree_dbh) + 0.207 * (log(tree_dbh))^2 - 0.0281*(log(tree_dbh))^3),
      TRUE ~ 0
    ),
    tree_agb_final = round(tree_agb_final, 3),
  )

```

### Tree belowground biomass

```{r}
#| eval: false
#| echo: true
#| lst-label: lst-treebgb
#| lst-cap: "Code snippet for tree belowground biomass."
#| filename: "Extract from R/user/05-tree-bgb.R"

tmp_subplot_agb <- tree |>
  group_by(subplot_plot_no, subplot_no) |>
  summarise(subplot_agb = round(sum(tree_agb_final * tree_weight / 5)/ 1000), .groups = "drop")

tree <- tree |>
  mutate(subplot_agb = NA) |>
  left_join(tmp_subplot_agb, by = join_by(subplot_plot_no, subplot_no), suffix = c("_rm", "")) |>
  select(-ends_with("_rm")) |>
  mutate(
    tree_rs = case_when(
      lu_code_new == "CF" & subplot_agb <  50 ~ 0.46,
      lu_code_new == "CF" & subplot_agb <= 150 ~ 0.32,
      lu_code_new == "CF" & subplot_agb >  150 ~ 0.23,
      lu_code_new != "CF" & subplot_agb <  125 ~ 0.2,
      lu_code_new != "CF" & subplot_agb >= 125 ~ 0.24,
      TRUE ~ NA_real_
    ),
    tree_bgb = round(tree_agb_final * tree_rs, 3),
  )

```

### Sapling aboveground biomass

TBD

### Standing deadwood aboveground biomass

TBD

### Stump aboveground biomass

TBD

### Lying deadwood biomass

TBD
